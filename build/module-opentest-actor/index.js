const spawn = require('child_process').spawn;
const fs = require('fs');
const path = require('path');
const yargs = require('yargs');

yargs.alias('w', 'workdir');

module.exports = {
    start: start
};

function start(options) {
    options = options || {};

    const workDir = /** @type string */ (options.workDir || yargs.argv.workdir || process.cwd());

    const opentestJarsPath = path.join(__dirname, 'jars', '*').replace(/\\/g, '/');
    const actorJarsPath = path.join(workDir, 'user-jars', '*').replace(/\\/g, '/');
    const classPath = `${actorJarsPath}${path.delimiter}${opentestJarsPath}`;

    options.args = options.args || [];

    // Add java debug options if you need remote debuging
    // '-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=127.0.0.1:5005'
    let allArgs = ['-cp', classPath, 'org.getopentest.Main', '--workdir', workDir];
    allArgs = allArgs.concat(options.args);

    const newProcess = spawn(
        'java',
        allArgs,
        { stdio: 'inherit' });

    newProcess.on('error', function (err) {
        console.log('ERROR: ' + err.message);
        if (err.code === 'ENOENT') {
            console.log('ERROR: Failed to start Java process. Please ensure that the Java runtime is properly installed.');
        }
    });

    // Write server process ID to disk. This can be used later to easily kill
    // the process from a CI pipeline or other automation tools.
    const pid = newProcess.pid || 0;
    try {
        fs.writeFileSync(path.join(workDir, 'actor.pid'), String(pid));
    } catch {
        // Nothing to do here
    }

    console.log(`Test actor PID: ${pid}`);

    return pid;
}
